pudusv._1107,COMPLETE CSE USERNAME
211525860,COMPLETE


1. To handle collisions
and brick removal, we selected the Strategy Pattern.
Instead of implementing logic directly within the Brick class,
we defined a CollisionStrategy interface,
where each brick holds a different strategy object make by the factory and delegates the collision handling (onCollision) to it.
The main advantage is the Open/Closed Principle: new behaviors (such as explosions or extra lives)
can be added easily without modifying existing Brick code, ensuring decoupling. The disadvantage
is the added complexity resulting from the increased number of classes and the need to pass multiple
dependencies (such as counters and object collections) through constructors to the various strategies
without the option to send directly functions from the game manger.

2.The life display was implemented using two dedicated classes,
GraphicLifeCounter and NumericLifeCounter, both holding a reference
to the same shared Counter object managed by the GameManager.
The implementation relies on state polling within the update loop:
in every frame, the classes independently check if the counter value has changed.
GraphicLifeCounter handles the visual aspect by dynamically updating the array of
heart objects (adding/removing them from the screen) according to the current life count,
while NumericLifeCounter manages the text display, updating the number and its color
(Green/Yellow/Red) based on the current status. This approach ensures full synchronization
with a single source of truth without requiring manual updates from the game manager.

3. We used a strategy design pattern: we have a BrickStrategiesFactory factory that chooses the
strategy according to the distribution described in the exercise. It creates a strategy object,
and returns it. Every brick contains ("has-a") strategy. All strategies implement the
CollisionStrategy interface, so the brick just has to invoke the onCollision method upon collision.
Puck -
We create a Ball with different arguments, since our pucks differs from a ball only in image and
size. The game manager knows who is the main ball, since it created it - so it knows to
decrement lives only when the main ball leaves the screen.
Extra paddle -
We created an ExtraPaddle class, which inherits from the Paddle class; this is due to the fact
that the relation between the two is an "is-a" (the extra paddle is still a paddle). The extra
paddle adds a counter to erase it when it had 4 collisions, and of course is initialized with
different parameters. The factory knows when an extra paddle already exists via a counter, and it
passes it to the ExtraPaddleStrategy and then to the extra paddle to notify him when it's
terminating itself.
COMPLETE: EXPLOSION AND EXTRA LIVESS

4. We implemented the double behavior using a decorator that holds two other behaviors, and invokes
them when the brick is hit. We enforced the N-behaviors limitation (in our case it's 3) by passing the
number to the factory's method getStrategy. The maximum number of behaviors allowed is defined in
the game manager to allow changing it with minimum code changed. Because a tree of N leafs has N-1 nodes,
we limited the amount of double behaviors to N-1 using a counter - and used a recursive function that
checks that counter every time it's called.

Note: We added a Constants class. This class holds only constants that are shared between classes;
constants that are relevant to one class only are in that class - keeping encapsulation.

