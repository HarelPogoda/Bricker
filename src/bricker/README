pudusv._1107,neorai.amrusi
211525860,318463187



1. To handle collisions
and brick removal, we selected the Strategy Pattern.
Instead of implementing logic directly within the Brick class,
we defined a CollisionStrategy interface,
where each brick holds a different strategy object make by the factory and delegates the collision handling (onCollision) to it.
The main advantage is the Open/Closed Principle: new behaviors (such as explosions or extra lives)
can be added easily without modifying existing Brick code, ensuring decoupling. The disadvantage
is the added complexity resulting from the increased number of classes and the need to pass multiple
dependencies (such as counters and object collections) through constructors to the various strategies
without the option to send directly functions from the game manger.

2.The life display was implemented using two dedicated classes,
GraphicLifeCounter and NumericLifeCounter, both holding a reference
to the same shared Counter object managed by the GameManager.
The implementation relies on state polling within the update loop:
in every frame, the classes independently check if the counter value has changed.
GraphicLifeCounter handles the visual aspect by dynamically updating the array of
heart objects (adding/removing them from the screen) according to the current life count,
while NumericLifeCounter manages the text display, updating the number and its color
(Green/Yellow/Red) based on the current status. This approach ensures full synchronization
with a single source of truth without requiring manual updates from the game manager.

3. We used a strategy design pattern: we have a BrickStrategiesFactory factory that chooses the
strategy according to the distribution described in the exercise. It creates a strategy object,
and returns it. Every brick contains ("has-a") strategy. All strategies implement the
CollisionStrategy interface, so the brick just has to invoke the onCollision method upon collision.
Puck -
We create a Ball with different arguments, since our pucks differs from a ball only in image and
size. The game manager knows who is the main ball, since it created it - so it knows to
decrement lives only when the main ball leaves the screen.
Extra paddle -
We created an ExtraPaddle class, which inherits from the Paddle class; this is due to the fact
that the relation between the two is an "is-a" (the extra paddle is still a paddle). The extra
paddle adds a counter to erase it when it had 4 collisions, and of course is initialized with
different parameters. The factory knows when an extra paddle already exists via a counter, and it
passes it to the ExtraPaddleStrategy and then to the extra paddle to notify him when it's
terminating itself.
ExplosionStrategy-
the brick breaks just like a normal brick, but in addition, it also causes the nearby
bricks around it to break as well. This creates a chain reaction, similar to
an explosion spreading outward. The code works by letting the BrickStrategiesFactory
create an ExplosionStrategy object. When the brick is hit, it simply calls the strategyâ€™s
onCollision method, and the strategy handles removing the brick and all the neighboring bricks.
This behavior is implemented as a strategy so that only selected bricks will explode,
while others keep their normal behavior.

ExtraLivesStrategy- is another special collision strategy.
When the ball hits a brick that uses this strategy, the brick breaks normally,
but the player can receives one extra life if hit the falling heart object that created.
the falling heart object when creates works and updated supratedly.
Only certain bricks give extra lives, so the BrickStrategiesFactory
creates this strategy only when needed. Like the other strategies, the brick just
calls onCollision, and the strategy handles everything. This keeps the behavior
clean and separate, and makes it easy to add additional special brick behaviors.

4. We implemented the double behavior using a decorator that holds two other behaviors, and invokes
them when the brick is hit. We enforced the N-behaviors limitation (in our case it's 3) by passing the
number to the factory's method getStrategy. The maximum number of behaviors allowed is defined in
the game manager to allow changing it with minimum code changed. Because a tree of N leafs has N-1 nodes,
we limited the amount of double behaviors to N-1 using a counter - and used a recursive function that
checks that counter every time it's called.

Note: We added a Constants class. This class holds only constants that are shared between classes;
constants that are relevant to one class only are in that class - keeping encapsulation.

